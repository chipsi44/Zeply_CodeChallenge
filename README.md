# **Zeply_CodeChallenge**

# Description : 

### **Context** : This project was created as part of a challenge for a company named Zeply.The purpose of this code challenge is to assess my technical skills, namely, code structure, code quality, naming conventions, knowledge of commonly used frameworks, and overall problem-solving skills. 

<br>

In this Python challenge we want you to implement a simple REST API for
generating valid cryptocurrency addresses and displaying them. 
Specifically, your API should provide three endpoints, as follows:
1. **Generate Address**  : The core functionality of the API is to take a cryptocurrency as input and return a valid
address for that currency as output. 
2. **List Addresses** : The List endpoint takes no input and returns a list of all the
addresses generated so far.
3. **Retrieve Addresses** : The Retrieve endpoint takes an ID, and returns the corresponding
address as stored in the database.

<br>

#  How to use :

1. Download or fork the project
2. Use pip install -r requirements.txt 
3. You can import the three endpoints from YourProjectFile.endpoints 

```
from YourProjectFile.endpoints import retrieve_address, list_address,generate_address
```

/!\ Please note that this project was created for training purposes to showcase my skills. To store the data generated by the 'generate_address' endpoints, I have hosted a database online. If you want to use your own database instead, you can modify the connection settings in 'data_management -> db_gestion.py'. However, please keep in mind that the 'generate_address' endpoint returns three values, which will be discussed later. /!\ 

**example** :
```
from endpoints import retrieve_address, list_address,generate_address
class TestStringMethods(unittest.TestCase):
    def integration_test(self) :
            '''If we create two row in the database using the same private key it should return the same private key and public         
             address'''
            seed1,private_key1,public_address1 = generate_address('BTC')
            seed2,private_key2,public_address2 = generate_address('BTC',private_key1)
            self.assertEqual([private_key1,public_address1], [private_key2,public_address2])

            '''Since list_address returns a list of all the elements in the database, 
            and the last two elements are exactly the same (except for the ID), we should be able to compare them.'''
            list_all_elements = list_address()
            self.assertEqual(list_all_elements[-2][1:],list_all_elements[-1][1:])
            
            '''
            Now that we have verified that the last two elements in the list of addresses are identical, 
            we can also check that they correspond by using retrieve_address and the id
            '''
            id1 = list_all_elements[-1][0]
            id2 = list_all_elements[-2][0]
            self.assertEqual(retrieve_address(id1)[1:], retrieve_address(id2)[1:])

if __name__ == '__main__':
    unittest.main()
```

**generate_address** : <br>

The 'generate_address' function is a Python endpoint that creates a cryptocurrency address based on a given 'coin' and optional 'private_key'. The function returns the generated 'seed', 'private_key', and 'public_address'. Additionally, the function registers the 'coin' and address in a database for record-keeping purposes.

Please note that this project is intended for training purposes only. If you plan to use the 'generate_address' function in a production environment, it is highly recommended that you modify the database connection in the 'data_management -> db_gestion.py' file to use your own database.

To use the 'generate_address' function, simply call the function and provide the desired 'coin' as the first argument. If you have a specific 'private_key' that you would like to use, you can provide it as the second argument. If no 'private_key' is provided, the function will generate a new one.

Once the function has been called, the generated address can be retrieved from the returned 'seed', 'private_key', and 'public_address' values

**retrieve_address** :<br>

The retrieve_address function takes an ID as its input and retrieves the corresponding address from the database. It uses the select_specified_id function located in data_management -> db_gestion.py to fetch the address associated with the provided ID. The function then returns the address as a string. It should be noted that this function is tailored to work with the specific database used in this project. If you plan to use this function in your own project, you will need to modify the database connection accordingly.


**list_address** :<br>

This function, list_address, is used to return a list of tuples containing all the addresses created so far. Each tuple consists of three elements: id, coin, and public_address. It retrieves this information from my own online database, so if you want to use this function for your own project, you will need to modify the database connection in data_management -> db_gestion.py.

# The database

The database used for this project is hosted on a free online service called render.com. It is a PostgreSQL database that contains a single table with columns for ID, coin, and public address. The instructions for connecting to the database can be found in data_management -> db_gestion.py.

Note that for security purposes and to avoid polluting the database, it will be taken offline once the project review is complete.

It's worth mentioning that since we don't use relations inside the database, a lightweight SQLite database file would have been sufficient. However, I wanted to demonstrate my ability to create a database on a hosted service, as well as showcase my experience using more advanced databases.

As a side note, I used pgAdmin to manage the PostgreSQL database. PgAdmin is a popular open-source administration and management tool for PostgreSQL, which provides a user-friendly interface for performing common database tasks.

# The main.py / unnittest

In the main.py file, I have written some easy unit tests to cover critical functionality. As this project has a tight deadline of three days, it may not be possible to test every aspect thoroughly. However, I have made sure to include tests that cover the most important functionalities.

It is important to note that testing is a specialized field that requires expertise, and additional tests can always be added to cover areas such as error handling and memory limitations. But for the purpose of this project, I have focused on writing tests that cover the essential functionalities.

To run the unit tests, simply execute the main.py file. The tests will be executed automatically, and the output will be displayed on the console. If any test fails, an error message will be displayed indicating which test has failed and what the expected output was.

# deployement Branch : 
As this project is meant to showcase my skills, I created a simple webpage and connected it to a Flask app to demonstrate how it could be used in a real-world project. I also developed a Dockerfile that is stored on Docker Hub. For more information, please refer to the Deployment branch

# Last note : 
Please note that this project was created as part of a company challenge, and the comments present in the code were added for the benefit of the recruiter.

To gain a better understanding of the functionalities implemented in this project, it is recommended that you review the source code. If you have any questions or concerns, please feel free to reach out to me for clarification.
